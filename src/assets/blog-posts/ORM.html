<p>Object Orientated Programmers think in terms of objects. The objects are defined by classes which contain properties associated with the object.</p>
<p>Relational Databases think in terms of tables of records. Each record has fields associated with that record.</p>
<p>Business applications require both relational databases to store the data as well as being able to convert that data to objects so that the developers can use them accordingly. Here enters a Object Relational Mapper (ORM) tool which does exactly as the name suggests; map objects to relational records and vice versa. This tool hence can significantly simplify the life of the developers.</p>
<p>Here I will outline the basic procedure to get Microsoft’s EntityFramework Core (the open source version of the arguably most popular ORM tool: EntityFramework). We will be using a PostgreSQL database and so will use the PostgreSQL version of the tool.</p>
<ol style="list-style-type: decimal">
<li>Download the EntityFramework Core tool</li>
</ol>
<p>dotnet tool install --global dotnet-ef</p>
<ol style="list-style-type: decimal">
<li>Begin a dotnet core project</li>
</ol>
<p>dotnet new console</p>
<ol start="2" style="list-style-type: decimal">
<li>Add package to the project</li>
</ol>
<p>dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL --version 5.0.7</p>
<ol start="3" style="list-style-type: decimal">
<li>Define entities. (An object which will have an associated table in database)</li>
</ol>
<p>public class Blogs { public int BlogId { get; set; } public string Url { get; set; } }</p>
<ol start="4" style="list-style-type: decimal">
<li>Define DB context and add entities to DB context</li>
</ol>
<p>public class BloggingContext : DbContext { public DbSet<Blog> Blogs { get; set; }</p>
<pre><code>    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        =&gt; optionsBuilder.UseNpgsql(&quot;Host=my_host;Database=my_db;Username=my_user;Password=my_pw&quot;);
}</code></pre>
<ol start="5" style="list-style-type: decimal">
<li><p>Add DB context to services (if building ASP.NET Core application) public void ConfigureServices(IServiceCollection services) { services.AddDbContext<BloggingContext>(options =&gt; options.UseNpgsql(Configuration.GetConnectionString(&quot;BloggingContext&quot;))); }</p></li>
<li><p>Add your first migration. Now migrations are interesting. They are like version control for databases. Say you want to add a new column to a database, you would first create a migration with this change. The migration not only holds the code to update the database with your new column but also holds the code to roll back the database before the change was made; just in case something breaks.</p></li>
</ol>
<p>dotnet ef migrations add <Name of Migration></p>
<ol start="7" style="list-style-type: decimal">
<li>The migration is just the snapshot of the changes we want to make. We must now update the database to reflect these changes</li>
</ol>
<p>dotnet ef database update</p>
<ol start="8" style="list-style-type: decimal">
<li>If all goes well you can check your database to see if the changes were applied correctly</li>
</ol>
<p>Great! We built a relational database from code (Code First). However, the entity created has no relationship with any other entity. In relational database design there are three types of relationships between entities (tables). They are defined as follows:</p>
<ul>
<li>One to One</li>
<li>One to Many</li>
<li>Many to Many</li>
</ul>
<ol style="list-style-type: decimal">
<li>Example for one to one</li>
</ol>
<p>Public class EntityA { Public int id { get; set; } Public string name { get; set; } } Public class EntityB { Public int id { get; set; } Public string name { get; set; } }</p>
<ol start="2" style="list-style-type: decimal">
<li>Example for one to many</li>
</ol>
<p>Public class EntityA { Public int id { get; set; } Public string name { get; set; } } Public class EntityB { Public int id { get; set; } Public string name { get; set; } Public IList<EntityA> CollectionOfEntities { get; set; } }</p>
<ol start="3" style="list-style-type: decimal">
<li>Example of Many to Many. Note: EntityFramework Core does not support this relationship out of the box. Instead we can get around this by creating 2 one to many relationships in both ways. Furthermore an intermediary entity will need to be created to represent the “joining table” required for a many to many relationship.</li>
</ol>
<p>Public class EntityA { Public int id { get; set; } Public string name { get; set; } Public IList<EntityAEntityB> CollectionOfEntitiesB { get; set; } }</p>
<p>Public class EntityB { Public int id { get; set; } Public string name { get; set; } Public IList<EntityAEntityB> CollectionOfEntitiesA { get; set; } }</p>
<p>Public class EntityAEntityB {</p>
<p>}</p>
<p>Now how do I interact with the database, like fet ching or adding records? Let me first discuss repository patterns.</p>
<p>Repository patterns are just a standardized way to interact with persistent storage. It follows the Domain Driven Design pattern for building software. Briefly DDD splits a large project into layers, whereby each layer is responsible for a single concern. Typical layers include:</p>
<ul>
<li>Core layer for modelling entities and business logic</li>
<li>EntityFramework layer handles migrations and DBContext</li>
<li>Application layer where our controllers are defined</li>
<li>Presentation layer handles how the data is presented to the user</li>
</ul>
<p>It should be noted you definitely can interact directly with the database just with the DBContext but this is not best practise with enterprise applications. You would rather have a layer that sits between you and the actual database access so that when you are interacting with the database you do not need to worry about implementing the connection to the database each time.</p>
<p>The steps to build a repository are as follows:</p>
<ol style="list-style-type: decimal">
<li>Implement a IRepository interface. Typical methods we want to define are Get, GetAll, Update etc. Good practise to define a structure for the repository before implementing it</li>
<li>Create an abstract Repository class which implements these methods.</li>
<li>Create Repository that inherits from abstract repository class</li>
<li>Use repository as a dependency injection into your application</li>
</ol>
<p>What are dependency injections? This is a technique whereby a class requests certain dependencies (other objects) without needing to create and manage these</p>
<p>Dependency Injections create and manage dependencies requested by another object thus removing the requesting object’s responsibility of managing those dependencies themselves. We can realise dependency injections using a dependency injection framework like Caste Windsor.</p>
